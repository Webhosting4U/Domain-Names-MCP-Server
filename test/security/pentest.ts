const BASE = process.argv[2] || "https://mcp-domains.webhosting4u.gr/mcp";
const VALID_EMAIL = process.env.PENTEST_EMAIL || process.argv[3] || "";
const VALID_KEY = process.env.PENTEST_API_KEY || process.argv[4] || "";

if (!VALID_EMAIL || !VALID_KEY) {
  console.error("Usage: npx tsx test/security/pentest.ts <base_url> <email> <api_key>");
  console.error("  Or set PENTEST_EMAIL and PENTEST_API_KEY environment variables.");
  process.exit(1);
}

const HEADERS = {
  "Content-Type": "application/json",
  Accept: "application/json, text/event-stream",
};

let sessionId: string | undefined;
let validSessionToken: string | undefined;
let requestId = 0;

interface TestResult {
  category: string;
  test: string;
  passed: boolean;
  detail: string;
}

const results: TestResult[] = [];

function record(category: string, test: string, passed: boolean, detail: string) {
  results.push({ category, test, passed, detail });
  const icon = passed ? "[PASS]" : "[FAIL]";
  console.log(`  ${icon} ${test}: ${detail}`);
}

async function mcpRequest(method: string, params: unknown): Promise<any> {
  requestId++;
  const body = JSON.stringify({
    jsonrpc: "2.0",
    id: requestId,
    method,
    params,
  });

  const hdrs: Record<string, string> = { ...HEADERS };
  if (sessionId) hdrs["mcp-session-id"] = sessionId;

  const resp = await fetch(BASE, { method: "POST", headers: hdrs, body });
  const text = await resp.text();

  if (text.startsWith("event:") || text.startsWith("data:")) {
    const lines = text.split("\n");
    for (const line of lines) {
      if (line.startsWith("data: ")) {
        try {
          return JSON.parse(line.slice(6));
        } catch {}
      }
    }
    return { raw: text };
  }

  try {
    return JSON.parse(text);
  } catch {
    return { raw: text };
  }
}

async function callTool(name: string, args: Record<string, unknown>): Promise<any> {
  return mcpRequest("tools/call", { name, arguments: args });
}

async function initialize(): Promise<void> {
  const initBody = JSON.stringify({
    jsonrpc: "2.0",
    id: 0,
    method: "initialize",
    params: {
      protocolVersion: "2025-03-26",
      capabilities: {},
      clientInfo: { name: "security-test", version: "1.0" },
    },
  });

  const resp = await fetch(BASE, { method: "POST", headers: HEADERS, body: initBody });
  sessionId = resp.headers.get("mcp-session-id") || undefined;
}

async function getValidSession(): Promise<string> {
  if (validSessionToken) return validSessionToken;
  const result = await callTool("auth_login", { email: VALID_EMAIL, api_key: VALID_KEY });
  const text = result?.result?.content?.[0]?.text;
  if (text) {
    const parsed = JSON.parse(text);
    validSessionToken = parsed.session_token;
    return validSessionToken!;
  }
  throw new Error("Could not obtain valid session");
}

// ====== TEST SUITES ======

async function testAuthBypass() {
  console.log("\n=== 1. AUTHENTICATION BYPASS ===");

  // 1a. Call tool without session_token
  const r1 = await callTool("system_version", {});
  const t1 = r1?.result?.content?.[0]?.text || "";
  const hasError1 = t1.includes("AUTH_REQUIRED") || t1.includes("error") || r1?.result?.isError;
  record("auth_bypass", "Tool without session_token", hasError1, hasError1 ? "Rejected" : `ALLOWED: ${t1}`);

  // 1b. Call tool with empty session_token
  const r2 = await callTool("system_version", { session_token: "" });
  const t2 = r2?.result?.content?.[0]?.text || JSON.stringify(r2?.error || r2);
  const hasError2 = t2.includes("AUTH") || t2.includes("error") || t2.includes("validation") || r2?.result?.isError || r2?.error;
  record("auth_bypass", "Empty session_token", !!hasError2, hasError2 ? "Rejected" : `ALLOWED: ${t2}`);

  // 1c. Forged session token (random hex)
  const r3 = await callTool("system_version", { session_token: "a".repeat(64) });
  const t3 = r3?.result?.content?.[0]?.text || "";
  const hasError3 = t3.includes("AUTH") || r3?.result?.isError;
  record("auth_bypass", "Forged session_token (random hex)", !!hasError3, hasError3 ? "Rejected" : `ALLOWED: ${t3}`);

  // 1d. Partial session token
  const token = await getValidSession();
  const r4 = await callTool("system_version", { session_token: token.slice(0, 16) });
  const t4 = r4?.result?.content?.[0]?.text || JSON.stringify(r4?.error || r4);
  const hasError4 = t4.includes("AUTH") || t4.includes("error") || r4?.result?.isError || r4?.error;
  record("auth_bypass", "Truncated valid token", !!hasError4, hasError4 ? "Rejected" : `ALLOWED: ${t4}`);

  // 1e. Login with wrong API key
  const r5 = await callTool("auth_login", { email: VALID_EMAIL, api_key: "WRONG_KEY_123456789" });
  const t5 = r5?.result?.content?.[0]?.text || "";
  const hasError5 = t5.includes("AUTH") || t5.includes("error") || r5?.result?.isError;
  record("auth_bypass", "Login with wrong API key", !!hasError5, hasError5 ? "Rejected" : `ALLOWED: ${t5.substring(0, 100)}`);

  // 1f. Login with wrong email
  const r6 = await callTool("auth_login", { email: "attacker@evil.com", api_key: VALID_KEY });
  const t6 = r6?.result?.content?.[0]?.text || "";
  const hasError6 = t6.includes("AUTH") || t6.includes("error") || r6?.result?.isError;
  record("auth_bypass", "Login with wrong email", !!hasError6, hasError6 ? "Rejected" : `ALLOWED: ${t6.substring(0, 100)}`);
}

async function testInjection() {
  console.log("\n=== 2. INJECTION ATTACKS ===");
  const token = await getValidSession();

  const sqlPayloads = [
    "' OR '1'='1",
    "'; DROP TABLE audit_log; --",
    "1 UNION SELECT * FROM sessions--",
    "admin'--",
  ];

  for (const payload of sqlPayloads) {
    const r = await callTool("domains_lookup", {
      session_token: token,
      searchTerm: payload,
      tldsToInclude: ["com"],
    });
    const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
    const noLeak = !t.includes("SQL") && !t.includes("syntax") && !t.includes("sqlite") && !t.includes("database");
    record("injection", `SQL in searchTerm: ${payload.substring(0, 30)}`, noLeak, noLeak ? "No SQL leak in response" : `LEAK: ${t.substring(0, 100)}`);
  }

  // XSS in domain
  const xssPayloads = [
    "<script>alert(1)</script>.com",
    "test\"><img src=x onerror=alert(1)>.com",
  ];

  for (const payload of xssPayloads) {
    const r = await callTool("domains_information_get", {
      session_token: token,
      domain: payload,
    });
    const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
    const sanitized = !t.includes("<script>") || t.includes("VALIDATION");
    record("injection", `XSS in domain: ${payload.substring(0, 30)}`, sanitized, sanitized ? "Rejected/sanitized" : `REFLECTED: ${t.substring(0, 100)}`);
  }

  // Path traversal
  const traversalPayloads = [
    "../../etc/passwd",
    "..%2F..%2Fetc%2Fpasswd",
    "example.com/../../admin",
    "example.com%00.evil.com",
  ];

  for (const payload of traversalPayloads) {
    const r = await callTool("domains_information_get", {
      session_token: token,
      domain: payload,
    });
    const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
    const safe = !t.includes("root:") && !t.includes("/etc/") && (t.includes("error") || t.includes("VALIDATION") || t.includes("UPSTREAM"));
    record("injection", `Path traversal: ${payload.substring(0, 30)}`, safe, safe ? "Rejected/safe" : `POSSIBLE ISSUE: ${t.substring(0, 100)}`);
  }

  // Command injection
  const cmdPayloads = [
    "example.com; ls -la",
    "example.com | cat /etc/passwd",
    "$(whoami).com",
    "`id`.com",
  ];

  for (const payload of cmdPayloads) {
    const r = await callTool("domains_information_get", {
      session_token: token,
      domain: payload,
    });
    const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
    const safe = !t.includes("uid=") && !t.includes("total ") && !t.includes("drwx");
    record("injection", `Cmd injection: ${payload.substring(0, 30)}`, safe, safe ? "No execution" : `EXECUTED: ${t.substring(0, 100)}`);
  }
}

async function testSSRF() {
  console.log("\n=== 3. SSRF ATTACKS ===");
  const token = await getValidSession();

  // Try to manipulate domain to probe internal services
  const ssrfPayloads = [
    "localhost",
    "127.0.0.1",
    "169.254.169.254",  // AWS metadata
    "0.0.0.0",
    "[::1]",
    "internal-service.local",
    "metadata.google.internal",
  ];

  for (const payload of ssrfPayloads) {
    const r = await callTool("domains_information_get", {
      session_token: token,
      domain: payload,
    });
    const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
    const safe = t.includes("error") || t.includes("VALIDATION") || t.includes("UPSTREAM");
    record("ssrf", `SSRF via domain: ${payload}`, safe, safe ? "Rejected" : `RESPONSE: ${t.substring(0, 100)}`);
  }

  // Attempt to inject URL in search term
  const r = await callTool("domains_lookup", {
    session_token: token,
    searchTerm: "http://evil.com/steal?cookie=",
    tldsToInclude: ["com"],
  });
  const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
  record("ssrf", "URL in searchTerm", true, `Response: ${t.substring(0, 80)}`);
}

async function testRateLimits() {
  console.log("\n=== 4. RATE LIMIT ENFORCEMENT ===");
  const token = await getValidSession();

  let hitLimit = false;
  const lookupCount = 15;
  for (let i = 0; i < lookupCount; i++) {
    const r = await callTool("domains_lookup", {
      session_token: token,
      searchTerm: `ratelimit${i}test`,
      tldsToInclude: ["com"],
    });
    const t = r?.result?.content?.[0]?.text || JSON.stringify(r?.error || r);
    if (t.includes("RATE_LIMITED")) {
      hitLimit = true;
      record("rate_limit", `Lookup rate limit hit at request ${i + 1}/${lookupCount}`, true, "Rate limiting enforced");
      break;
    }
  }

  if (!hitLimit) {
    record("rate_limit", `Lookup rate limit after ${lookupCount} rapid requests`, false,
      "No rate limit triggered (limit may be higher than test count)");
  }
}

async function testDataLeakage() {
  console.log("\n=== 5. INFORMATION LEAKAGE ===");
  const token = await getValidSession();

  // Check error responses don't contain sensitive data
  const r1 = await callTool("domains_information_get", {
    session_token: token,
    domain: "nonexistent-domain-12345.com",
  });
  const t1 = r1?.result?.content?.[0]?.text || JSON.stringify(r1?.error || r1);
  const noApiKey = !t1.includes(VALID_KEY) && !t1.includes("api_key") && !t1.includes("apiKey");
  const noToken = !t1.includes("token:") && !t1.includes("base64_encode") && !t1.includes("hash_hmac");
  const noStack = !t1.includes("at ") && !t1.includes("stack") && !t1.includes(".ts:");
  record("data_leak", "Error response has no API key", noApiKey, noApiKey ? "Clean" : `LEAKED API KEY`);
  record("data_leak", "Error response has no upstream token", noToken, noToken ? "Clean" : `LEAKED TOKEN`);
  record("data_leak", "Error response has no stack trace", noStack, noStack ? "Clean" : `LEAKED STACK`);

  // Login error should not reveal which field is wrong
  const r2 = await callTool("auth_login", { email: "wrong@wrong.com", api_key: "WrongKey1234567890" });
  const t2 = r2?.result?.content?.[0]?.text || "";
  const genericError = !t2.includes("email not found") && !t2.includes("wrong password") && !t2.includes("user does not exist");
  record("data_leak", "Login error is generic (no user enumeration)", genericError, genericError ? "Generic error" : `ENUMERABLE: ${t2.substring(0, 80)}`);

  // Check that valid session response doesn't leak api_key
  const r3 = await callTool("auth_login", { email: VALID_EMAIL, api_key: VALID_KEY });
  const t3 = r3?.result?.content?.[0]?.text || "";
  const noKeyInLogin = !t3.includes(VALID_KEY) && !t3.includes("api_key");
  record("data_leak", "Login response doesn't return api_key", noKeyInLogin, noKeyInLogin ? "Clean" : `LEAKED: ${t3.substring(0, 80)}`);
}

async function testSessionSecurity() {
  console.log("\n=== 6. SESSION SECURITY ===");

  // 6a. Session token entropy - check it's long enough random hex
  const token = await getValidSession();
  const isHex = /^[a-f0-9]{64}$/.test(token);
  record("session", "Token is 64-char hex (256-bit entropy)", isHex, isHex ? `Token: ${token.substring(0, 8)}...` : `Format: ${token.substring(0, 20)}`);

  // 6b. Logout actually invalidates token
  const logoutToken = (await (async () => {
    const r = await callTool("auth_login", { email: VALID_EMAIL, api_key: VALID_KEY });
    return JSON.parse(r?.result?.content?.[0]?.text).session_token;
  })());

  await callTool("auth_logout", { session_token: logoutToken });
  const r2 = await callTool("system_version", { session_token: logoutToken });
  const t2 = r2?.result?.content?.[0]?.text || JSON.stringify(r2?.error || r2);
  const invalidated = t2.includes("AUTH") || r2?.result?.isError;
  record("session", "Logout invalidates token", !!invalidated, invalidated ? "Token rejected after logout" : `STILL VALID: ${t2.substring(0, 80)}`);

  // 6c. Cross-session isolation - one user's token can't access another session
  const token2 = token.replace(/[0-9]/g, (c: string) => String((parseInt(c) + 1) % 10));
  const r3 = await callTool("system_version", { session_token: token2 });
  const t3 = r3?.result?.content?.[0]?.text || "";
  const isolated = t3.includes("AUTH") || r3?.result?.isError;
  record("session", "Modified token rejected (session isolation)", !!isolated, isolated ? "Rejected" : `ACCEPTED: ${t3.substring(0, 80)}`);

  // 6d. Can't use session_token as api_key
  const r4 = await callTool("auth_login", { email: VALID_EMAIL, api_key: token });
  const t4 = r4?.result?.content?.[0]?.text || "";
  const rejected = t4.includes("AUTH") || t4.includes("error") || r4?.result?.isError;
  record("session", "Session token rejected as API key", !!rejected, rejected ? "Rejected" : `ACCEPTED: ${t4.substring(0, 80)}`);
}

async function testInputAbuse() {
  console.log("\n=== 7. INPUT ABUSE ===");
  const token = await getValidSession();

  // 7a. Oversized input
  const bigInput = "a".repeat(10000);
  const r1 = await callTool("domains_lookup", {
    session_token: token,
    searchTerm: bigInput,
    tldsToInclude: ["com"],
  });
  const t1 = r1?.result?.content?.[0]?.text || JSON.stringify(r1?.error || r1);
  const handled = t1.includes("error") || t1.includes("VALIDATION") || r1?.error;
  record("input_abuse", "Oversized searchTerm (10KB)", !!handled, handled ? "Rejected/handled" : `ACCEPTED: ${t1.substring(0, 80)}`);

  // 7b. Null bytes
  const r2 = await callTool("domains_information_get", {
    session_token: token,
    domain: "example\x00evil.com",
  });
  const t2 = r2?.result?.content?.[0]?.text || JSON.stringify(r2?.error || r2);
  const noNull = !t2.includes("evil") || t2.includes("error") || t2.includes("VALIDATION");
  record("input_abuse", "Null byte in domain", noNull, noNull ? "Handled safely" : `ISSUE: ${t2.substring(0, 80)}`);

  // 7c. Unicode homograph attack
  const r3 = await callTool("domains_lookup", {
    session_token: token,
    searchTerm: "gооgle",  // Cyrillic 'о' instead of Latin 'o'
    tldsToInclude: ["com"],
  });
  const t3 = r3?.result?.content?.[0]?.text || JSON.stringify(r3?.error || r3);
  record("input_abuse", "Unicode homograph (Cyrillic o)", true, `Response: ${t3.substring(0, 80)}`);

  // 7d. Array where string expected
  const r4 = await callTool("system_version", {
    session_token: [token, "extra"],
  });
  const t4 = r4?.result?.content?.[0]?.text || JSON.stringify(r4?.error || r4);
  const typeChecked = t4.includes("error") || t4.includes("VALIDATION") || r4?.result?.isError || r4?.error;
  record("input_abuse", "Array where string expected", !!typeChecked, typeChecked ? "Type-checked" : `ACCEPTED: ${t4.substring(0, 80)}`);

  // 7e. Massive TLD array
  const manyTlds = Array.from({ length: 500 }, (_, i) => `tld${i}`);
  const r5 = await callTool("domains_lookup", {
    session_token: token,
    searchTerm: "test",
    tldsToInclude: manyTlds,
  });
  const t5 = r5?.result?.content?.[0]?.text || JSON.stringify(r5?.error || r5);
  record("input_abuse", "500-element TLD array", true, `Response length: ${t5.length} chars`);

  // 7f. Prototype pollution attempt
  const r6 = await callTool("domains_lookup", {
    session_token: token,
    searchTerm: "test",
    tldsToInclude: ["com"],
    __proto__: { admin: true },
    constructor: { prototype: { admin: true } },
  } as any);
  const t6 = r6?.result?.content?.[0]?.text || JSON.stringify(r6?.error || r6);
  record("input_abuse", "Prototype pollution attempt", true, `Response: ${t6.substring(0, 80)}`);
}

// ====== MAIN ======
async function main() {
  console.log(`=== MCP Server Security Audit ===`);
  console.log(`Target: ${BASE}\n`);

  await initialize();
  console.log(`MCP session initialized (id: ${sessionId || "none"})`);

  await testAuthBypass();
  await testInjection();
  await testSSRF();
  await testRateLimits();
  await testDataLeakage();
  await testSessionSecurity();
  await testInputAbuse();

  // Cleanup
  if (validSessionToken) {
    await callTool("auth_logout", { session_token: validSessionToken });
  }

  // Summary
  console.log("\n\n========== SECURITY AUDIT SUMMARY ==========");
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Total tests: ${results.length}`);
  console.log(`Passed: ${passed}`);
  console.log(`Failed: ${failed}`);

  if (failed > 0) {
    console.log("\n--- FAILURES ---");
    for (const r of results.filter(r => !r.passed)) {
      console.log(`  [FAIL] ${r.category} > ${r.test}: ${r.detail}`);
    }
  }

  console.log("\n========================================");
  process.exit(failed > 0 ? 1 : 0);
}

main().catch(console.error);
